

# Funciones (parte 2 de 3)

Además de las funciones más habituales, Python incluye otras utilidades que permiten trabajar de forma más avanzada con **iterables**, **objetos**, **archivos** y **clases**. Estas funciones son especialmente útiles para escribir código más expresivo, dinámico y flexible.

---

## Funciones integradas adicionales

| Función | Descripción |
|-------|-------------|
| `enumerate()` | Añade un índice a cada elemento de un iterable |
| `zip()` | Combina varios iterables en pares de elementos |
| `open()` | Abre un archivo para lectura, escritura o modificación |
| `isinstance()` | Comprueba si una variable es de un tipo específico |
| `issubclass()` | Verifica la relación de herencia entre clases |
| `hasattr()` | Comprueba si un objeto contiene un atributo |
| `getattr()` | Obtiene el valor de un atributo de un objeto |
| `setattr()` | Asigna un valor a un atributo de un objeto |
| `delattr()` | Elimina un atributo de un objeto |
| `help()` | Muestra la documentación de un objeto o módulo |
| `id()` | Devuelve el identificador único de un objeto en memoria |
| `next()` | Retorna el siguiente valor de un iterador |
| `iter()` | Convierte un iterable en un iterador |
| `chr()`, `ord()` | Trabajan con la representación Unicode de caracteres |
| `bin()`, `oct()`, `hex()` | Convierte enteros a distintas bases numéricas |
| `any()`, `all()` | Evalúan condiciones sobre iterables (al menos uno o todos) |

---

Estas funciones aportan un mayor control sobre el comportamiento del código y permiten aprovechar mejor las características internas del lenguaje.